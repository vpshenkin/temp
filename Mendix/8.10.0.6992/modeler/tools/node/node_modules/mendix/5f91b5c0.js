import{K as fromRequest$,m as loading,C as readUntracked,f as available,S as scheduleSideEffect,k as fromComputation$}from"./2252f97c.js";import{t as toObjectItem}from"./dc685e13.js";import{w as withObjectKeeping$}from"./194b06f4.js";import{a as asReloadableListValue$,w as withPageInfoSharing$,o as objectListTrigger,g as getDelayedPageSetters,b as getImmediatePageSetters}from"./dd6506a6.js";function getServerPagedList$(config,store,widgetId,parameters$,fetch){const{fetchTrigger$:fetchTrigger$,page$:page$,silentlyResetOffset:silentlyResetOffset}=objectListTrigger(config,store,widgetId,parameters$),listChunk$=fromRequest$("Load data of "+widgetId,()=>{const trigger=fetchTrigger$.dependOn();if(!trigger.load)return loading();const{parameters:parameters,id:triggerId}=trigger;if("available"!==parameters.status)return parameters;const currentChunk=readUntracked(fixedListChunk$),page=page$.dependOn(),{sliceToKeep:sliceToKeep,pageToFetch:pageToFetch,loadAtEnd:loadAtEnd}=function(currentList,nextPage){if("available"!==currentList.status)return{};const[currentStart,currentEnd]=[currentList.value.offset,currentList.value.offset+currentList.value.limit],[newStart,newEnd]=[nextPage.offset,nextPage.offset+nextPage.limit],[keepStart,keepEnd]=[Math.max(currentStart,newStart),Math.min(currentEnd,newEnd)];if(keepStart>=keepEnd)return{};if(newStart<keepStart&&newEnd>keepEnd)return{};const loadAtEnd=newEnd>currentEnd,pageToFetch={offset:loadAtEnd?keepEnd:newStart,limit:newEnd-newStart-(keepEnd-keepStart)};return{sliceToKeep:[keepStart-currentStart,keepEnd-currentStart],loadAtEnd:loadAtEnd,pageToFetch:pageToFetch.limit>0?pageToFetch:void 0}}(currentChunk,page);if("available"!==currentChunk.status||currentChunk.value.triggerId!==triggerId||void 0===sliceToKeep)return fetch(parameters.value,page).then(({mxobjs:mxobjs,count:count})=>available(Object.assign(Object.assign({},page),{parameters:parameters.value,triggerId:triggerId,objects:mxobjs,totalCount:count})));if(void 0===pageToFetch)return available(Object.assign(Object.assign(Object.assign({},currentChunk.value),page),{objects:currentChunk.value.objects.slice(...sliceToKeep)}));{const reusedObjects=currentChunk.value.objects.slice(...sliceToKeep);return[currentChunk,fetch(parameters.value,pageToFetch).then(({mxobjs:mxobjs})=>available(Object.assign(Object.assign(Object.assign({},currentChunk.value),page),{objects:loadAtEnd?reusedObjects.concat(mxobjs):mxobjs.concat(reusedObjects)})))]}}),fixedListChunk$=fromRequest$("Retry to load data of "+widgetId,()=>{const loadedChunk=listChunk$.dependOn();if("available"!==loadedChunk.status)return loadedChunk;if(loadedChunk.value.objects.length>0||0===loadedChunk.value.offset)return loadedChunk;scheduleSideEffect(silentlyResetOffset);const{limit:limit}=readUntracked(page$);return fetch(loadedChunk.value.parameters,{limit:limit,offset:0}).then(({mxobjs:mxobjs,count:count})=>available(Object.assign(Object.assign({},loadedChunk.value),{limit:limit,offset:0,objects:mxobjs,totalCount:count})))}),subscribedListChunk$=withObjectKeeping$(widgetId,fixedListChunk$,listChunk=>listChunk.objects.map(o=>o.getGuid())),delayedPageSetters=getDelayedPageSetters(store,widgetId),immediatePageSetters=getImmediatePageSetters(store,widgetId),listValue$=fromComputation$("Prepare data of "+widgetId,()=>{const listChunk=subscribedListChunk$.dependOn();let result;if("available"===listChunk.status){const{objects:objects,totalCount:totalCount,offset:offset,limit:limit}=listChunk.value;result=Object.assign({status:"available",offset:offset,limit:limit,items:objects.map(toObjectItem),hasMoreItems:offset+objects.length<totalCount,totalCount:totalCount},delayedPageSetters)}else result=Object.assign(Object.assign({status:listChunk.status},readUntracked(page$)),immediatePageSetters);return result});return asReloadableListValue$(withPageInfoSharing$(listValue$,store,widgetId))}export{getServerPagedList$ as g};
