import{o as observable,k as fromComputation$,r as runActionInComputed,q as createAtom,e as comparer,c as computed,b as action,t as runInAction,f as available}from"./2252f97c.js";import{createContext,useState,useContext,useMemo,useLayoutEffect,createElement}from"react";import{h as tuple,A as AssertionError,u as useIsFirstRender}from"./e81b9882.js";import{Big}from"big.js";class CascadingStore{constructor(name,introduceScope,parentStore){this.name=name,this.introduceScope=introduceScope,this.parentStore=parentStore,this.entries$=observable.map(void 0,{deep:!1})}useSlot(widgetId,slot){const{get$:get$,set:set}=this.getOrCreateEntry(widgetId,slot);return tuple(fromComputation$(`${slot} of ${widgetId}`,get$),set)}get$(widgetId,slot){return this.getOrCreateEntry(widgetId,slot).get$()}set(widgetId,slot,value){this.getOrCreateEntry(widgetId,slot).set(value)}hasSlot(widgetId,slot){var _a;return this.introduceScope?this.entries$.has(toKey(widgetId,slot)):Boolean(null===(_a=this.parentStore)||void 0===_a?void 0:_a.hasSlot(widgetId,slot))}getOrCreateEntry(widgetId,slot){var _a;const key=toKey(widgetId,slot);if(this.entries$.has(key))return this.entries$.get(key);const parentOwnsValue=!this.introduceScope||Boolean(null===(_a=this.parentStore)||void 0===_a?void 0:_a.hasSlot(widgetId,slot)),newEntry={widgetId:widgetId,slot:slot,get$:()=>value.get(),set:v=>setValue(v),parentOwnsValue:parentOwnsValue,isObserved:observable.box(!1)};runActionInComputed(()=>this.entries$.set(key,newEntry));const trackingAtom=createAtom(`tracking for ${slot} of ${widgetId}`,()=>{runActionInComputed(()=>newEntry.isObserved.set(!0))},()=>{runActionInComputed(()=>newEntry.isObserved.set(!1))}),localBox=observable.box(void 0,{deep:!1,equals:comparer.structural}),value=computed(()=>(parentOwnsValue&&!trackingAtom.isBeingObserved&&runActionInComputed(()=>localBox.set(this.parentStore.get$(widgetId,slot))),trackingAtom.reportObserved(),localBox.get()),{name:`${this.name}'s value for widget ${widgetId} slot ${slot}`}),setValue=action(newValue=>{localBox.set(newValue),parentOwnsValue&&this.parentStore.set(widgetId,slot,newValue)});return newEntry}getAll$(slot){return Array.from(this.entries$.values()).filter(entry=>!entry.parentOwnsValue&&entry.slot===slot).map(entry=>({widgetId:entry.widgetId,value:entry.get$()}))}updateFromParent(){runInAction(()=>{Array.from(this.entries$.values()).filter(entry=>entry.parentOwnsValue&&entry.isObserved.get()).forEach(({widgetId:widgetId,slot:slot})=>{this.set(widgetId,slot,this.parentStore.get$(widgetId,slot))})})}subscribeToDependencies(onChange){return computed(()=>Array.from(this.entries$.values()).filter(entry=>entry.parentOwnsValue&&entry.isObserved.get()).map(({widgetId:widgetId,slot:slot})=>({widgetId:widgetId,slot:slot,value:this.parentStore.get$(widgetId,slot)})),{name:"dependency subscription on parent for "+this.name}).observe(({newValue:newValue,oldValue:oldValue})=>{newValue.some(({widgetId:widgetId,slot:slot,value:value})=>{const existingValue=oldValue.find(x=>x.widgetId===widgetId&&x.slot===slot);return void 0!==existingValue&&existingValue.value!==value})&&onChange()})}}function toKey(widgetId,slot){return JSON.stringify({widgetId:widgetId,slot:slot})}const persistableSlots=["limit","offset","selection","collapsed"];class StoreRegistry{constructor(viewState){this.viewState=viewState,this.scopedStores=observable.map(void 0,{deep:!1})}register(storePath,store){runInAction(()=>{this.scopedStores.set(storePath,store),this.viewState.filter(vs=>vs.path===storePath).forEach(vs=>{return store.set(vs.widgetId,vs.slot,(slot=vs.slot,"string"!=typeof(value=vs.value)||"limit"!==slot&&"offset"!==slot?value:new Big(value)));var slot,value})})}unregister(storePath,store){this.scopedStores.get(storePath)===store&&this.scopedStores.delete(storePath)}getAll$(slot){return Array.from(this.scopedStores.values()).flatMap(store=>store.getAll$(slot).map(x=>x.value))}collectViewState(){return Array.from(this.scopedStores.entries()).flatMap(([storePath,store])=>persistableSlots.flatMap(slot=>store.getAll$(slot).map(({widgetId:widgetId,value:value})=>({path:storePath,widgetId:widgetId,slot:slot,value:fromStoreValue(value)}))))}}function fromStoreValue(value){return value instanceof Big?value.toString():value}const StoreContext=createContext(void 0),StorePathContext=createContext("*"),StoreRegistryContext=createContext(void 0);function useStore(){return useContext(StoreContext)}function createRootStore(viewState){const registry=new StoreRegistry(viewState),store=new CascadingStore("root store",!0);return registry.register("*",store),[registry,store]}function useComponentStore(){const[,forceUpdate]=useState({}),parentStore=useStore(),result=useMemo(()=>new CascadingStore(`component store of (${parentStore.name})`,!1,parentStore),[]);return useSubscribeAndUpdate(result,forceUpdate),result}const RootStoreProvider=props=>createElement(StoreRegistryContext.Provider,{value:props.registry},createElement(StoreContext.Provider,{value:props.store},props.children));RootStoreProvider.displayName="RootStoreProvider";const NestedStoreProvider=props=>{const parentStore=useStore(),storeRegistry=useContext(StoreRegistryContext),[,forceUpdate]=useState({});if(void 0===storeRegistry)throw new Error("Component must be wrapped inside <RootStoreProvider>");const nestedStorePath=function(parent,namespace){if(namespace.includes(";"))throw new AssertionError("Illegal character ';' in namespace: "+namespace);return`${parent};${namespace}`}(useContext(StorePathContext),props.namespace),nestedStore=useMemo(()=>{const store=new CascadingStore(`nested store of (${parentStore.name})`,!0,parentStore);return storeRegistry.register(nestedStorePath,store),store},[]);return useSubscribeAndUpdate(nestedStore,forceUpdate),useLayoutEffect(()=>()=>storeRegistry.unregister(nestedStorePath,nestedStore),[]),useMemo(()=>nestedStore.set(props.scope,"object",available(props.object)),[props.object]),createElement(StorePathContext.Provider,{value:nestedStorePath},createElement(StoreContext.Provider,{value:nestedStore},props.children))};function useSubscribeAndUpdate(store,forceUpdate){useLayoutEffect(()=>store.subscribeToDependencies(()=>forceUpdate({})),[]),useIsFirstRender()||store.updateFromParent()}NestedStoreProvider.displayName="NestedStoreProvider";export{NestedStoreProvider as N,RootStoreProvider as R,createRootStore as c,useComponentStore as u};
