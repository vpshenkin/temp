import{useMemo}from"react";var isMergeableObject=function(value){return function(value){return!!value&&"object"==typeof value}(value)&&!function(value){var stringValue=Object.prototype.toString.call(value);return"[object RegExp]"===stringValue||"[object Date]"===stringValue||function(value){return value.$$typeof===REACT_ELEMENT_TYPE}(value)}(value)};var REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for?Symbol.for("react.element"):60103;function cloneUnlessOtherwiseSpecified(value,options){return!1!==options.clone&&options.isMergeableObject(value)?deepmerge((val=value,Array.isArray(val)?[]:{}),value,options):value;var val}function defaultArrayMerge(target,source,options){return target.concat(source).map((function(element){return cloneUnlessOtherwiseSpecified(element,options)}))}function getKeys(target){return Object.keys(target).concat(function(target){return Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(target).filter((function(symbol){return target.propertyIsEnumerable(symbol)})):[]}(target))}function propertyIsOnObject(object,property){try{return property in object}catch(_){return!1}}function mergeObject(target,source,options){var destination={};return options.isMergeableObject(target)&&getKeys(target).forEach((function(key){destination[key]=cloneUnlessOtherwiseSpecified(target[key],options)})),getKeys(source).forEach((function(key){(function(target,key){return propertyIsOnObject(target,key)&&!(Object.hasOwnProperty.call(target,key)&&Object.propertyIsEnumerable.call(target,key))})(target,key)||(propertyIsOnObject(target,key)&&options.isMergeableObject(source[key])?destination[key]=function(key,options){if(!options.customMerge)return deepmerge;var customMerge=options.customMerge(key);return"function"==typeof customMerge?customMerge:deepmerge}(key,options)(target[key],source[key],options):destination[key]=cloneUnlessOtherwiseSpecified(source[key],options))})),destination}function deepmerge(target,source,options){(options=options||{}).arrayMerge=options.arrayMerge||defaultArrayMerge,options.isMergeableObject=options.isMergeableObject||isMergeableObject,options.cloneUnlessOtherwiseSpecified=cloneUnlessOtherwiseSpecified;var sourceIsArray=Array.isArray(source);return sourceIsArray===Array.isArray(target)?sourceIsArray?options.arrayMerge(target,source,options):mergeObject(target,source,options):cloneUnlessOtherwiseSpecified(source,options)}deepmerge.all=function(array,options){if(!Array.isArray(array))throw new Error("first argument should be an array");return array.reduce((function(prev,next){return deepmerge(prev,next,options)}),{})};var cjs=deepmerge;class AssertionError extends Error{constructor(message="Unexpected error occurred, please contact your system administrator."){super(message),Object.setPrototypeOf(this,AssertionError.prototype)}}function ensure(arg){if(null==arg)throw new Error("Did not expect an argument to be undefined");return arg}function crash(){throw new AssertionError}function friendlyName(Component){var _a,_b;return null!==(_b=null!==(_a=Component.displayName)&&void 0!==_a?_a:Component.name)&&void 0!==_b?_b:"<component>"}function isDefined(value){return void 0!==value}function isString(value){return"string"==typeof value}function isJson(obj){return null!=obj&&"object"==typeof obj&&obj.constructor==={}.constructor}function isArrayOf(type,value){return value instanceof Array&&value.every(v=>void 0===v||v instanceof type)}function splitAttributePath(attributePath){const parts=attributePath.split("/");return parts.length>1&&parts.shift(),{attribute:parts.pop(),entityPath:parts.length?parts.join("/"):void 0}}function unique(list){return Array.from(new Set(list))}function partition(predicate,array){const matching=new Array,unmatching=new Array;return array.forEach(item=>predicate(item)?matching.push(item):unmatching.push(item)),[matching,unmatching]}function tuple(...args){return args}function mapValues(source,mapValue){const result={};return Object.keys(source).forEach(key=>result[key]=mapValue(source[key])),result}function uniqueBy(list,keySelector){const res=[],keys={};return list.forEach(item=>{const key=keySelector(item);Object.prototype.hasOwnProperty.call(keys,key)||(keys[key]=!0,res.push(item))}),res}function concat(arrays){return[].concat(...arrays)}function escapeXml(s){return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&apos;")}function containsKey(key,obj){return Object.prototype.hasOwnProperty.call(obj,key)}function flatten(objects){return cjs.all(objects.filter(object=>void 0!==object))}function lowerCaseFirst(str){return str.length>0?str[0].toLowerCase()+str.slice(1):""}function toFriendlyId(widgetId){const parts=widgetId.split(/\./g);return parts.length>=4?parts.slice(1,4).join("."):widgetId}function toWidgetName(widgetId){const parts=widgetId.split(/\./g);return parts.length>=4?parts[3]:void 0}function useIsFirstRender(){let result=!1;return useMemo(()=>{result=!0},[]),result}export{AssertionError as A,unique as a,uniqueBy as b,concat as c,isDefined as d,ensure as e,friendlyName as f,flatten as g,tuple as h,isJson as i,crash as j,isString as k,lowerCaseFirst as l,mapValues as m,isArrayOf as n,containsKey as o,partition as p,escapeXml as q,toFriendlyId as r,splitAttributePath as s,toWidgetName as t,useIsFirstRender as u};
