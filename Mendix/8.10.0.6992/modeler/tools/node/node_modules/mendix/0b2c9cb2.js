import{k as fromComputation$,l as dependOnSubscription,h as getOrElseL,m as loading,n as subscriptionDependency}from"./2252f97c.js";import{e as ensure,k as isString,n as isArrayOf,A as AssertionError,j as crash,o as containsKey}from"./e81b9882.js";import{Big}from"big.js";import{i as runtimeValueToAttributeValue,j as delocalizeDate,l as localizeDate,M as MxObject,k as clientToAttributeValue}from"./e4677d80.js";import{t as toMendixPattern,p as parseDate,g as getLocale,f as formatDate,c as addMilliseconds,d as addSeconds,e as addMinutes,h as addHours,i as addDays,j as addWeeks,k as addMonths,l as addYears,m as startOfSecond,n as startOfMinute,o as startOfHour,q as startOfDay,r as startOfMonth,u as startOfYear,b as parseNumber,a as formatNumber,v as getDateFnsLocale,w as endOfMinute,x as endOfHour,y as endOfDay,z as startOfWeek,A as endOfWeek,B as endOfMonth,C as endOfYear}from"./d1a3b52a.js";import{d as deepEqual}from"./275ae0e7.js";const pageScope="$pageParameter";const dirtyGuids=new Array;function markAsDirty(guids){dirtyGuids.push(...guids.filter(guid=>!dirtyGuids.includes(guid)))}function unmarkAsDirty(guid){dirtyGuids.includes(guid)&&dirtyGuids.splice(dirtyGuids.indexOf(guid),1)}function clearDirtyGuids(){dirtyGuids.splice(0,dirtyGuids.length)}function operationErrorText(operator,...args){return`Operator ${operator} not supported in expression ${operator}(${args.join(", ")})`}const addFunctionMap={addMilliseconds:addMilliseconds,addSeconds:addSeconds,addMinutes:addMinutes,addHours:addHours,addDays:addDays,addWeeks:addWeeks,addMonths:addMonths,addYears:addYears},trimFunctionMap={trimToSeconds:startOfSecond,trimToMinutes:startOfMinute,trimToHours:startOfHour,trimToDays:startOfDay,trimToMonths:startOfMonth,trimToYears:startOfYear},expressionDateFunctions=Object.assign(Object.assign(Object.assign({dateTime:(...args)=>evaluateCreateDateTime(args,!1,operationErrorText("dateTime",...args)),dateTimeUTC:(...args)=>evaluateCreateDateTime(args,!0,operationErrorText("dateTimeUTC",...args)),parseDateTime:(...args)=>evaluateParseDateTime(args,!1,operationErrorText("parseDateTime",...args)),parseDateTimeUTC:(...args)=>evaluateParseDateTime(args,!0,operationErrorText("parseDateTimeUTC",...args)),formatDate:arg=>evaluateFormatDate(arg,{type:"date"},!1,operationErrorText("formatDate",arg)),formatDateUTC:arg=>evaluateFormatDate(arg,{type:"date"},!0,operationErrorText("formatDateUTC",arg)),formatTime:arg=>evaluateFormatDate(arg,{type:"time"},!1,operationErrorText("formatTime",arg)),formatTimeUTC:arg=>evaluateFormatDate(arg,{type:"time"},!0,operationErrorText("formatTimeUTC",arg)),formatDateTime:(...args)=>evaluateFormatDate(args[0],toFormatterConfig(args[1]),!1,operationErrorText("formatDateTime",...args)),formatDateTimeUTC:(...args)=>evaluateFormatDate(args[0],toFormatterConfig(args[1]),!0,operationErrorText("formatDateTimeUTC",...args))},createExpressionFunctionCollection({millisecondsBetween:1,secondsBetween:1e3,minutesBetween:6e4,hoursBetween:36e5,daysBetween:864e5,weeksBetween:6048e5},(function(args,scale,errorText){const firstDate=args[0],secondDate=args[1];if(firstDate instanceof Date&&secondDate instanceof Date){return new Big(firstDate.getTime()).sub(secondDate.getTime()).abs().div(scale)}throw new Error(errorText)}),!1)),createExpressionFunctionCollection(addFunctionMap,(function(args,addFunction,errorText,utc){let date=args[0];const add=args[1];if(date instanceof Date&&add instanceof Big){utc&&(date=localizeDate(date));let newDate=addFunction(date,Number(add));return utc&&(newDate=delocalizeDate(newDate)),newDate}throw new Error(errorText)}),!0)),createExpressionFunctionCollection(trimFunctionMap,(function(args,trimFunction,errorText,utc){let date=args[0];if(date instanceof Date){utc&&(date=localizeDate(date));let newDate=trimFunction(date);return utc&&(newDate=delocalizeDate(newDate)),newDate}throw new Error(errorText)}),!0));function evaluateCreateDateTime(args,utc,errorText){const numbers=args.map(arg=>{if(arg instanceof Big)return Number(arg);throw new Error(errorText)});return 1===numbers.length&&numbers.push(1),numbers[1]=numbers[1]-1,utc?new Date(Date.UTC(...numbers)):new Date(...numbers)}function evaluateParseDateTime(args,utc,errorText){const[value,pattern,fallback]=args;if("string"==typeof value&&"string"==typeof pattern){const parsed=parseDate(value.trim(),{type:"custom",pattern:toMendixPattern(pattern.trim())});if(parsed instanceof Date)return utc?delocalizeDate(parsed):parsed;if(fallback instanceof Date)return fallback;throw new Error(`Unparseable date: "${value}"`)}throw new Error(errorText)}function evaluateFormatDate(arg,formatterConfig,utc,errorText){if(arg instanceof Date)return utc&&(arg=localizeDate(arg)),"custom"!==formatterConfig.type&&(formatterConfig={type:"custom",pattern:getLocale().nanoflowPatterns[formatterConfig.type]}),formatDate(arg,formatterConfig);throw new Error(errorText)}function createExpressionFunctionCollection(functionMap,evaluator,utcVariant){return Object.keys(functionMap).reduce((collection,name)=>{const parameter=functionMap[name];if(collection[name]=(...args)=>evaluator(args,parameter,operationErrorText(name,...args)),utcVariant){const utcName=name+"UTC";collection[utcName]=(...args)=>evaluator(args,parameter,operationErrorText(utcName,...args),!0)}return collection},{})}function toFormatterConfig(pattern){return"string"==typeof pattern?{type:"custom",pattern:toMendixPattern(pattern)}:{type:"datetime"}}const expressionListFunctions={_newList:()=>[],_toList:arg1=>asList(arg1,operationErrorText("_toList",arg1)),_addToList(arg1,arg2){const arr1=asList(arg1,operationErrorText("_addToList",arg1,arg2)),arr2=asList(arg2,operationErrorText("_addToList",arg1,arg2));return arr1.concat(arr2.filter(guid=>!arr1.includes(guid)))},_removeFromList(arg1,arg2){const arr1=asList(arg1,operationErrorText("_removeFromList",arg1,arg2)),arr2=asList(arg2,operationErrorText("_removeFromList",arg1,arg2));return arr1.filter(guid=>!arr2.includes(guid))},_intersectLists(arg1,arg2){const arr1=asList(arg1,operationErrorText("_intersectLists",arg1,arg2)),arr2=asList(arg2,operationErrorText("_intersectLists",arg1,arg2));return arr1.filter(guid=>arr2.includes(guid))},_listContains(arg1,arg2){const arr1=asList(arg1,operationErrorText("_listContains",arg1,arg2)),arr2=asList(arg2,operationErrorText("_listContains",arg1,arg2));return arr2.length>0&&arr2.every(guid=>arr1.includes(guid))},_head(arg1){if(arg1 instanceof Array)return arg1.length>0?arg1[0]:void 0;if(void 0!==arg1)throw new Error(operationErrorText("_head",arg1))}};function asList(arg,errorText){if(arg instanceof Array)return arg;if(isString(arg))return arg.length>0?[arg]:[];if(void 0===arg)return[];throw new Error(errorText)}const expressionLogicFunctions={not:arg=>!arg,"=":(arg1,arg2)=>arg1 instanceof Big&&arg2 instanceof Big?arg1.eq(arg2):arg1 instanceof Date&&arg2 instanceof Date?arg1.getTime()===arg2.getTime():"string"==typeof arg1||"string"==typeof arg2?(null!=arg1?arg1:"")===(null!=arg2?arg2:""):arg1 instanceof Array&&arg2 instanceof Array?arg1.length===arg2.length&&arg1.every(elem=>arg2.includes(elem)):arg1 instanceof Array&&void 0===arg2?0===arg1.length:void 0===arg1&&arg2 instanceof Array?0===arg2.length:arg1===arg2,"!=":(arg1,arg2)=>!expressionLogicFunctions["="](arg1,arg2),">"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.gt(arg2);if(arg1 instanceof Date&&arg2 instanceof Date)return arg1.getTime()>arg2.getTime();if(void 0===arg1||void 0===arg2)throw new Error(operationErrorText(">",arg1,arg2));return arg1>arg2},">=":(arg1,arg2)=>expressionLogicFunctions["="](arg1,arg2)||expressionLogicFunctions[">"](arg1,arg2),"<"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.lt(arg2);if(arg1 instanceof Date&&arg2 instanceof Date)return arg1.getTime()<arg2.getTime();if(void 0===arg1||void 0===arg2)throw new Error(operationErrorText("<",arg1,arg2));return arg1<arg2},"<=":(arg1,arg2)=>expressionLogicFunctions["="](arg1,arg2)||expressionLogicFunctions["<"](arg1,arg2)},expressionMathFunctions={"+"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.plus(arg2);if("string"==typeof arg1)return arg1+(void 0!==arg2?arg2.toString():"");if("string"==typeof arg2)return(void 0!==arg1?arg1.toString():"")+arg2;throw new Error(operationErrorText("+",arg1,arg2))},"-"(arg1,arg2){if(1===arguments.length&&void 0!==arg1)return arg1.times(-1);if(void 0!==arg1&&void 0!==arg2)return arg1.minus(arg2);throw new Error(operationErrorText("-",arg1,arg2))},"*"(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.times(arg2);throw new Error(operationErrorText("*",arg1,arg2))},div(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.div(arg2);throw new Error(operationErrorText("div",arg1,arg2))},mod(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.mod(arg2);throw new Error(operationErrorText("mod",arg1,arg2))},":":(arg1,arg2)=>expressionMathFunctions.div(arg1,arg2),max(...args){if(args[0]instanceof Big)return args.reduce((n1,n2)=>n1.gt(n2)?n1:n2);if(args[0]instanceof Date)return args.reduce((d1,d2)=>d1.getTime()>d2.getTime()?d1:d2);throw new Error(operationErrorText("max",...args))},min(...args){if(args[0]instanceof Big)return args.reduce((n1,n2)=>n1.lt(n2)?n1:n2);if(args[0]instanceof Date)return args.reduce((d1,d2)=>d1.getTime()<d2.getTime()?d1:d2);throw new Error(operationErrorText("min",...args))},round(arg,dp){if(arg instanceof Big)return arg.round(void 0===dp?0:Number(dp));throw new Error(operationErrorText("round",arg))},random:()=>new Big(Math.random()),floor(arg){if(arg instanceof Big){const fractional=arg.mod(1);return fractional.eq(0)?arg.eq(-0)?arg.abs():arg:arg.minus(fractional).minus(arg.lt(0)?1:0)}throw new Error(operationErrorText("floor",arg))},ceil(arg){if(arg instanceof Big){const result=expressionMathFunctions.floor(arg.times(-1));return result.eq(0)?result:result.times(-1)}throw new Error(operationErrorText("ceil",arg))},pow(arg,exponent){if(arg instanceof Big&&exponent instanceof Big)return arg.pow(Number(exponent));throw new Error(operationErrorText("pow",arg))},abs(arg){if(arg instanceof Big)return arg.abs();throw new Error(operationErrorText("abs",arg))}},expressionStringFunctions={toUpperCase:arg1=>asString(arg1).toUpperCase(),toLowerCase:arg1=>asString(arg1).toLowerCase(),trim:arg1=>asString(arg1).trim(),contains:(arg1,arg2)=>asString(arg1).includes(asString(arg2)),startsWith:(arg1,arg2)=>(arg1=asString(arg1),arg2=asString(arg2),arg1.substr(0,arg2.length)===arg2),endsWith:(arg1,arg2)=>(arg1=asString(arg1),arg2=asString(arg2),arg1.substr(arg1.length-arg2.length)===arg2),substring(arg1,arg2,arg3){if(arg1=asString(arg1),arg3=arg3,null==(arg2=arg2)?void 0:arg2.gte(0)){if(2===arguments.length)return arg1.substr(Number(arg2));if(null==arg3?void 0:arg3.gte(0))return arg1.substr(Number(arg2),Number(arg3))}throw new Error(operationErrorText("substring",arg1,arg2,arg3))},find(arg1,arg2,arg3){if(arg1=asString(arg1),arg2=asString(arg2),2===arguments.length)return new Big(arg1.indexOf(arg2));if(void 0!==arg3)return new Big(arg1.indexOf(arg2,Number(arg3)));throw new Error(operationErrorText("find",arg1,arg2,arg3))},findLast(arg1,arg2,arg3){if(arg1=asString(arg1),arg2=asString(arg2),2===arguments.length)return new Big(arg1.lastIndexOf(arg2));if(void 0!==arg3)return new Big(arg1.lastIndexOf(arg2,Number(arg3)));throw new Error(operationErrorText("findLast",arg1,arg2,arg3))},length:arg1=>new Big(asString(arg1).length),urlEncode:arg1=>encodeURIComponent(asString(arg1)).replace("%20","+"),urlDecode:arg1=>decodeURIComponent(asString(arg1).replace("+","%20")),isMatch(arg1,arg2){if(void 0!==arg2)return new RegExp(`^(${arg2})$`).test(asString(arg1));throw new Error(operationErrorText("isMatch",arg1,arg2))},replaceFirst(arg1,arg2,arg3){if(void 0!==arg2&&void 0!==arg3){const escapedForReplaceValue=arg3.replace(/\$/g,"$$$$");return asString(arg1).replace(new RegExp(arg2),escapedForReplaceValue)}throw new Error(operationErrorText("replaceFirst",arg1,arg2))},replaceAll(arg1,arg2,arg3){if(void 0!==arg2&&void 0!==arg3){const escapedForReplaceValue=arg3.replace(/\$/g,"$$$$");return asString(arg1).replace(new RegExp(arg2,"g"),escapedForReplaceValue)}throw new Error(operationErrorText("replaceAll",arg1,arg2))}};function asString(arg){return void 0===arg?"":arg}const expressionFunctions=Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},expressionDateFunctions),expressionListFunctions),expressionLogicFunctions),expressionMathFunctions),expressionStringFunctions),{toString:arg1=>arg1 instanceof Big?arg1.toString():void 0===arg1?"":arg1 instanceof Date?formatDate(arg1,{type:"datetime"}):String(arg1),parseInteger(arg,defaultValue){if("string"==typeof arg){if(/^-?\d+$/.test(arg)){const result=new Big(arg);return result.eq(-0)?result.abs():result}if(void 0===defaultValue)throw new Error("Not parsable to Integer: "+arg);return defaultValue}throw new Error(operationErrorText("parseInteger",arg))},parseDecimal(arg,defaultValue){if("string"==typeof arg){const parsed=parseNumber(arg);if(void 0===parsed&&void 0===defaultValue)throw new Error("Not parsable to Decimal: "+arg);return void 0===parsed?defaultValue:parsed}throw new Error(operationErrorText("parseDecimal",arg))},formatDecimal(arg){if(arg instanceof Big)return formatNumber(arg);throw new Error(operationErrorText("formatDecimal",arg))},isNew:arg1=>void 0!==arg1&&mx.data.isNew(arg1),isSynced(arg1){if(void 0!==arg1)return guid=arg1,!dirtyGuids.includes(guid);var guid;throw new Error(operationErrorText("isSynced",arg1))},_hasSomeRole:(...args)=>mx.session.hasSomeRole(args),_isNamedUser:()=>!mx.session.isGuest()});class AccessDeniedError extends Error{constructor(variableName,entityName,attributeName){super(`Unable to get a member from variable $${variableName}, because you do not have sufficient permissions to "${entityName}.${attributeName}".`),this.variableName=variableName,this.entityName=entityName,this.attributeName=attributeName,Object.setPrototypeOf(this,AccessDeniedError.prototype)}}class EmptyVariableAccessError extends Error{constructor(variableName){super(`Unable to get a member from an empty variable $${variableName}.`),this.variableName=variableName,Object.setPrototypeOf(this,EmptyVariableAccessError.prototype)}}class Resolver{constructor(getVariable){this.getVariable=getVariable,this.dependencies=[]}resolve(variable,path){return void 0!==path?this.resolveAttribute(variable,path):this.resolveVariable(variable)}getDependencies(){return this.dependencies.slice()}resolveVariable(name){const value=this.getVariable(name);if(value instanceof MxObject)return this.addDependency({guid:value.getGuid()}),value.getGuid();if(isArrayOf(MxObject,value)){const guids=value.map(obj=>obj.getGuid());return guids.forEach(guid=>this.addDependency({guid:guid})),guids}return value}resolveAttribute(variable,attribute){const obj=this.getVariable(variable);if(void 0===obj)throw new EmptyVariableAccessError(variable);if(!(obj instanceof MxObject))throw new AssertionError;if(!obj.has(attribute))throw new AccessDeniedError(variable,obj.getEntity(),attribute);return this.addDependency({guid:obj.getGuid()}),this.addDependency({guid:obj.getGuid(),attr:attribute}),clientToAttributeValue(obj.get(attribute),obj.getAttributeType(attribute))}addDependency(dependency){this.dependencies.find(dep=>deepEqual(dep,dependency))||this.dependencies.push(dependency)}}const funcMap={beginOfCurrentMinute:startOfMinute,endOfCurrentMinute:endOfMinute,beginOfCurrentHour:startOfHour,endOfCurrentHour:endOfHour,beginOfCurrentDay:startOfDay,endOfCurrentDay:endOfDay,beginOfCurrentWeek:startOfWeek,endOfCurrentWeek:endOfWeek,beginOfCurrentMonth:startOfMonth,endOfCurrentMonth:endOfMonth,beginOfCurrentYear:startOfYear,endOfCurrentYear:endOfYear};function createExpressionTokens(getNow){const tokensCollection={currentUser:()=>mx.session.getUserId(),currentDateTime:getNow};return Object.keys(funcMap).forEach(exposedName=>{const func=funcMap[exposedName];tokensCollection[exposedName]=()=>func(getNow(),{locale:getDateFnsLocale()}),tokensCollection[exposedName+"UTC"]=()=>delocalizeDate(func(localizeDate(getNow())))}),tokensCollection}const evaluator=new class{constructor(expressionFunctions,expressionTokens,getConstants){this.expressionFunctions=expressionFunctions,this.expressionTokens=expressionTokens,this.getConstants=getConstants}evaluate(expr,resolver){switch(expr.type){case"function":if(void 0===this.expressionFunctions[expr.name])throw new Error(`Function ${expr.name} is not known`);const values=expr.parameters.map(exp=>this.evaluate(exp,resolver));return this.expressionFunctions[expr.name].apply(null,values);case"literal":return"number"==typeof expr.value?new Big(expr.value):null===expr.value?void 0:expr.value;case"variable":return void 0!==expr.path?resolver.resolve(expr.variable,expr.path):resolver.resolve(expr.variable);case"conditional":return this.evaluate(expr.condition,resolver)?this.evaluate(expr.then,resolver):this.evaluate(expr.else,resolver);case"token":if(void 0===this.expressionTokens[expr.name])throw new Error(`Token ${expr.name} is not known`);return this.expressionTokens[expr.name]();case"constant":const constant=ensure(this.getConstants().find(({name:name})=>expr.name===name));return runtimeValueToAttributeValue(constant.value,constant.type)}}}(expressionFunctions,createExpressionTokens(()=>new Date),()=>mx.session.getConstants());function evaluateExpression(expression,getVariable,outDependencies=[]){const resolver=new Resolver(getVariable);try{return evaluator.evaluate(expression,resolver)}finally{outDependencies.push(...resolver.getDependencies())}}function evaluateFormExpression$(expression,store,description,extraArgs={}){const dependencies=[];try{return evaluateExpression(expression.expr,param=>{var _a;return containsKey(param,extraArgs)?extraArgs[param]():getOrElseL(null!==(_a=store.get$(expression.args[param],"object"))&&void 0!==_a?_a:loading(),void 0)},dependencies)}finally{dependencies.map(dependency=>subscriptionDependency(description,dependency)).forEach(atom=>atom.reportObserved())}}function getFormExpressionResult$(expression,store,description,extraArgs={}){const expressionArgs={};for(const key of Object.keys(expression.args))expressionArgs[key]=store.useSlot(expression.args[key],"object")[0];return fromComputation$(description,()=>{const dependencies=[],attribute=evaluateExpression(expression.expr,param=>{var _a;return containsKey(param,extraArgs)?extraArgs[param].dependOn():getOrElseL(null!==(_a=param in expressionArgs?expressionArgs[param].dependOn():null)&&void 0!==_a?_a:loading(),void 0)},dependencies);return dependencies.forEach(dependency=>dependOnSubscription(dependency)),attribute})}function evaluateFlowExpression(expr,scope,resultKind){const exprResult=evaluateExpression(expr,name=>scope.get(name));switch(resultKind){case"primitive":return exprResult;case"list":return Array.isArray(exprResult)?scope.mapGuidsToObjects(exprResult):void 0===exprResult?[]:crash();case"object":return"string"==typeof exprResult?scope.mapGuidsToObjects([exprResult])[0]:void 0===exprResult?void 0:crash()}}export{AccessDeniedError as A,EmptyVariableAccessError as E,createExpressionTokens as a,evaluateFlowExpression as b,clearDirtyGuids as c,evaluateFormExpression$ as d,expressionFunctions as e,getFormExpressionResult$ as g,markAsDirty as m,pageScope as p,unmarkAsDirty as u};
