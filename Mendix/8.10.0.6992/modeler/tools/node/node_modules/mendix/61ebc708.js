import{n as subscriptionDependency,u as unavailable,f as available,x as flatMapL,m as loading,y as using,w as mapL,z as flattenArrayL,A as loadableResource,o as observable}from"./2252f97c.js";import{A as AssertionError}from"./e81b9882.js";import{n as newId}from"./3cf8690e.js";import{q as attributeToClientValue,k as clientToAttributeValue}from"./e4677d80.js";import{n as notAccessible,A as Access,a as accessible}from"./449717b5.js";class MxObject1{constructor(mxObject){this.mxObject=mxObject,this.attributeDependencies={},this.objectDependency=subscriptionDependency("Object "+mxObject.getGuid(),{guid:mxObject.getGuid()});const metaObject=mx.meta.getEntity(mxObject.getEntity());for(const attr of metaObject.getAttributes())this.attributeDependencies[attr]=subscriptionDependency(`Attribute ${attr} of object ${mxObject.getGuid()}`,{guid:mxObject.getGuid(),attr:attr})}getGuid(){return this.mxObject.getGuid()}getEntity(){return this.mxObject.getEntity()}getAttributeType(attr){return this.mxObject.getAttributeType(attr)}old(){return this.mxObject}get$(attribute){return this.objectDependency.reportObserved(),Object.prototype.hasOwnProperty.call(this.attributeDependencies,attribute)?(this.attributeDependencies[attribute].reportObserved(),function(mxObject,attribute){const access=getAccess(mxObject,attribute);if(access===Access.None)return notAccessible();const value=clientToAttributeValue(mxObject.get(attribute),mxObject.getAttributeType(attribute));return accessible(value,access)}(this.mxObject,attribute)):notAccessible()}set(attribute,value){if(getAccess(this.mxObject,attribute)!==Access.Write)throw new AssertionError("No write access to attribute "+attribute);this.mxObject.set(attribute,attributeToClientValue(value))}getByPath$(path){const pathSteps=path.split("/");let objectSoFar=this;for(;pathSteps.length;){const[association,entity]=pathSteps.splice(0,2),reference=objectSoFar.get$(association);if(reference.access===Access.None||void 0===reference.value)return unavailable();const cachedObject=mx.data.getCachedObject(reference.value),nextObject=cachedObject?MxObject1.from$(cachedObject):fetchObject$(reference.value);if("available"!==nextObject.status)return nextObject;if(!mx.meta.getEntity(nextObject.value.getEntity()).isA(entity))return unavailable();objectSoFar=nextObject.value}return available(objectSoFar)}static from$(mxObject){if(mxObject.isUnavailable())return unavailable();const mxObject1=mxObject.__cached_mxObj1||(mxObject.__cached_mxObj1=new MxObject1(mxObject));return mxObject1.objectDependency.reportObserved(),available(mxObject1)}static fromState$(state){return void 0!==state?flatMapL(state,v=>MxObject1.from$(v)):loading()}}function getAccess(mxObject,attribute){return mxObject.has(attribute)?mxObject.isReadonlyAttr(attribute)?Access.Read:Access.Write:Access.None}const fetchObjectResources=new Map;function fetchObject$(guid){const resource=cacheBy(fetchObjectResources,guid,()=>loadableResource(`fetching object '${guid}'`,()=>new Promise((resolve,reject)=>mx.data.get({guid:guid,callback(obj){resolve(obj?available(obj):unavailable())},error:reject}))));return flatMapL(resource.get(),MxObject1.from$)}const fetchObjectsResources=new Map;function fetchObjects$(guids){guids.sort((a,b)=>a.localeCompare(b));const resource=cacheBy(fetchObjectsResources,guids,()=>loadableResource("fetching objects "+guids.join(", "),()=>guids.length>0?new Promise((resolve,reject)=>mx.data.get({guids:guids,callback:objs=>resolve(available(objs)),error:reject})):available([])));return mapL(resource.get(),objs=>flattenArrayL(objs.map(MxObject1.from$)))}const serverValidationResources=new Map;function serverValidate$(name,guid,attribute){return cacheBy(serverValidationResources,[guid,attribute],()=>{const lastSeenValidation=observable.box(void 0,{deep:!1});return using(()=>{const handle=mx.data.subscribe({tag:name,guid:guid,attr:attribute,val:!0,callback:msg=>lastSeenValidation.set([msg,newId()])});return[handle.unsubscribe.bind(handle)]},()=>lastSeenValidation.get())}).get()}function cacheBy(cache,key,createResource){const keyStr=JSON.stringify(key),cachedResource=cache.get(keyStr);if(void 0!==cachedResource)return cachedResource;const resource=createResource(),newResource=using(()=>(cache.set(keyStr,newResource),[()=>cache.delete(keyStr)]),()=>resource.get());return newResource}export{MxObject1 as M,fetchObjects$ as f,serverValidate$ as s};
