import{s as subscribe}from"./2252f97c.js";import{A as AssertionError,q as escapeXml,p as partition}from"./e81b9882.js";import{e as expressionFunctions,a as createExpressionTokens,b as evaluateFlowExpression}from"./0b2c9cb2.js";import{Big}from"big.js";import{k as clientToAttributeValue,n as anyToExpressionVariable,M as MxObject,p as expressionVariableToRuntimeValue,q as attributeToClientValue}from"./e4677d80.js";class ObjectValidation{constructor(guid,fields){this._guid=guid,this._fields=fields}getGuid(){return this._guid}getAttributes(){return Object.keys(this._fields).map(name=>({name:name,reason:this._fields[name]}))}getFields(){return this.getAttributes()}static describe(validations){const list=[];for(let i=0;void 0!==validations[i];i++){const fields=validations[i].getFields();for(let x=0;void 0!==fields[x];x++)list.push(fields[x].reason)}return list.join("\n")}addAttribute(attr,message){return!(attr in this._fields)&&(this._fields[attr]=message,!0)}addField(...args){return this.addAttribute(...args)}removeAttribute(attr){return attr in this._fields&&(delete this._fields[attr],!0)}removeField(...args){return this.removeAttribute(...args)}getErrorReason(attr){return this._fields[attr]}getReasonByAttribute(...args){return this.getErrorReason(...args)}clone(){return new ObjectValidation(this._guid,Object.assign({},this._fields))}toString(){return Object.keys(this._fields).map(attr=>`${attr} ${this._fields[attr]}`).join("; ")}}async function withFinally(promise,finallyFun){return promise.then(d=>(finallyFun(),d),e=>(finallyFun(),Promise.reject(e)))}async function never(){return new Promise(()=>{})}async function wait(timeout=0){return new Promise(resolve=>{setTimeout(()=>{resolve()},timeout)})}async function methodToPromise(subject,functionName,...args){return new Promise((resolve,reject)=>subject[functionName](...args,resolve,reject))}var AggregateFunction;ObjectValidation.fromResponse=function(datavalidation){return datavalidation.map(({guid:guid,errorFields:errorFields})=>{const fieldMap={};return errorFields.forEach(({name:name,message:message})=>{fieldMap[name]=message}),new ObjectValidation(guid,fieldMap)})},function(AggregateFunction){AggregateFunction.Sum="Sum",AggregateFunction.Average="Average",AggregateFunction.Count="Count",AggregateFunction.Minimum="Minimum",AggregateFunction.Maximum="Maximum"}(AggregateFunction||(AggregateFunction={}));class AggregateExecutor{constructor(){this.instructionType="aggregate"}async execute(instruction,scope){const inputList=scope.get(instruction.inputVar);Array.isArray(inputList)&&(instruction.operation===AggregateFunction.Count?scope.set(instruction.outputVar,new Big(inputList.length)):scope.set(instruction.outputVar,function(inputList,operation,member){const inputValues=inputList.map(obj=>obj.get(member)).filter(val=>val instanceof Big);switch(operation){case AggregateFunction.Minimum:return 0===inputValues.length?void 0:inputValues.reduce((curMin,curVal)=>curVal.lt(curMin)?curVal:curMin,inputValues[0]);case AggregateFunction.Maximum:return 0===inputValues.length?void 0:inputValues.reduce((curMax,curVal)=>curVal.gt(curMax)?curVal:curMax,inputValues[0]);case AggregateFunction.Average:return 0===inputValues.length?void 0:sum(inputValues).div(inputValues.length);case AggregateFunction.Sum:return sum(inputValues)}return}(inputList,instruction.operation,instruction.member)))}}function sum(values){return values.reduce((sumValue,curValue)=>sumValue.plus(curValue),new Big(0))}class FilterListExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="filterList"}async execute(instruction,scope){const input=scope.get(instruction.inputVar),expected=this.evaluateExp(instruction.expectedValue,scope,"primitive"),result=Array.isArray(input)?input.filter((function(obj){const value=obj.get(instruction.attribute),type=obj.getAttributeType(instruction.attribute);return expressionFunctions["="](clientToAttributeValue(value,type),expected)})):[];scope.set(instruction.outputVar,instruction.retrieveSingleObject?result.length>0?result[0]:void 0:result)}}class JavaScriptActionExecutor{constructor(evaluateExp,executeNanoflow){this.evaluateExp=evaluateExp,this.executeNanoflow=executeNanoflow,this.instructionType="javaScriptActionCall"}async execute(instruction,scope){const resolvedParameters=instruction.parameters.map(param=>"nanoflowId"===param.kind?this.createNanoflowWrapper(param.value,scope):this.evaluateExp(param.value,scope,param.kind)),action=await async function(jsActionId){return jsActionId()}(instruction.action),result=await action(...resolvedParameters);instruction.outputVar&&scope.set(instruction.outputVar,anyToExpressionVariable(result))}createNanoflowWrapper(nanoflowId,scope){if(void 0!==nanoflowId)return(args={})=>{const flatArgs=Object.keys(args).map(name=>({name:name,value:anyToExpressionVariable(args[name])}));return this.executeNanoflow(nanoflowId,flatArgs,scope.currentForm)}}}class JumpExecutor{constructor(){this.instructionType="jump"}async execute(instruction,_scope){return{goto:instruction.target}}}class LoopExecutor{constructor(executeInstructions){this.executeInstructions=executeInstructions,this.instructionType="loop"}async execute(instruction,scope){const list=scope.get(instruction.listVar);if(!Array.isArray(list))throw new AssertionError;for(const obj of list)if(scope.set(instruction.iteratorVar,obj),await this.executeInstructions(instruction.body,scope))break}}class MicroflowCallExecutor{constructor(evaluateFlowExpression){this.evaluateFlowExpression=evaluateFlowExpression,this.instructionType="microflowCall"}async execute({flow:flow,parameters:parameters,outputVar:outputVar},scope){const microflowParameters=this.toMicroflowArguments(parameters,scope),result=mx.isOffline()?await mx.offlineData.executeMicroflow(flow,microflowParameters):await mx.onlineData.executeMicroflow(flow,microflowParameters,scope.currentForm);void 0!==outputVar&&scope.set(outputVar,result)}toMicroflowArguments(parameters,scope){const microflowArgs={};return parameters.forEach(({name:name,value:value,kind:kind})=>{const expressionResult=this.evaluateFlowExpression(value,scope,kind);if("object"===kind&&expressionResult instanceof MxObject)microflowArgs[name]={guid:expressionResult.getGuid()};else if("list"===kind&&Array.isArray(expressionResult))microflowArgs[name]={guids:expressionResult.map(mxobj=>mxobj.getGuid())};else if("primitive"===kind){const runtimeValue=expressionVariableToRuntimeValue(expressionResult);null!==runtimeValue&&(microflowArgs[name]={value:runtimeValue})}}),microflowArgs}}class NanoflowCallExecutor{constructor(evaluateExpression,executeNanoflow){this.evaluateExpression=evaluateExpression,this.executeNanoflow=executeNanoflow,this.instructionType="nanoflowCall"}async execute({flow:flow,parameters:parameters,outputVar:outputVar},scope){const args=parameters.map(parameter=>({name:parameter.name,value:this.evaluateExpression(parameter.value,scope,parameter.kind)})),result=await this.executeNanoflow(flow,args,scope.currentForm);void 0!==outputVar&&scope.set(outputVar,result)}}class AssociationRetrieveExecutor{constructor(){this.instructionType="associationRetrieve"}async execute(instruction,scope){const{inputVar:inputVar,association:association,entity:entity,retrieveSingleObject:retrieveSingleObject,direction:direction,outputVar:outputVar}=instruction,obj=scope.get(inputVar);if(void 0===obj)return void scope.set(outputVar,retrieveSingleObject?void 0:[]);if(!(obj instanceof MxObject))throw new AssertionError;const mxobjs=await async function(mxobj,path,entity,direction){return new Promise((resolve,reject)=>{mx.data.get({guid:mxobj.getGuid(),path:path,entity:entity,direction:direction,callback:resolve,error:reject})})}(obj,association,entity,direction);scope.set(outputVar,retrieveSingleObject?mxobjs[0]:mxobjs)}}class NanoflowError extends Error{constructor(message){super(message),Object.setPrototypeOf(this,NanoflowError.prototype)}}class ChangeObjectExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="changeObject"}async execute(instruction,scope){const obj=scope.get(instruction.inputVar);if(void 0===obj)throw new NanoflowError(`Cannot change $${instruction.inputVar} as it is empty`);if(!(obj instanceof MxObject))throw new AssertionError;const exprValue=this.evaluateExp(instruction.value,scope,"primitive");let clientValue=attributeToClientValue(exprValue);clientValue instanceof Big&&(clientValue=clientValue.round(8)),obj.set(instruction.member,clientValue)}}class CommitObjectsExecutor{constructor(){this.instructionType="commitObjects"}async execute(instruction,scope){const variable=scope.get(instruction.inputVar);if(variable instanceof MxObject)await commit([variable]);else{if(!Array.isArray(variable))throw void 0===variable?new NanoflowError(`Cannot commit $${instruction.inputVar} as it is empty`):new AssertionError;await commit(variable)}}}async function commit(mxobjs){return new Promise((resolve,reject)=>mx.data.commit({mxobjs:mxobjs,callback:resolve,error:reject}))}class CreateObjectExecutor{constructor(){this.instructionType="createObject"}async execute(instruction,scope){const obj=await new Promise((resolve,reject)=>mx.data.create({entity:instruction.objectType,callback:resolve,error:reject}));scope.set(instruction.outputVar,obj)}}const expressionTokens=createExpressionTokens(()=>new Date);function toQueryFilterValue(source,attribute){if(null!=source){if("string"==typeof source||"boolean"==typeof source||source instanceof Date||source instanceof Big)return source;if("number"==typeof source)return new Big(source);if(source instanceof MxObject){if(void 0!==attribute){return clientToAttributeValue(source.get(attribute),source.getAttributeType(attribute))}return source.getGuid()}throw new AssertionError(`Cannot use value '${source}' in query filter`)}}function toXpathConstraint(filter){switch(filter.type){case"attribute":return filter.attribute;case"value":const value=filter.value;if(void 0===value)return"empty";if("string"==typeof value)return`'${escapeXml(value)}'`;if("boolean"==typeof value)return value?"true()":"false()";if(value instanceof Big)return value.toString();if(value instanceof Date)return value.getTime().toString();throw new AssertionError;case"function":return/^(\W+|and|or)$/.test(filter.name)?"("+filter.parameters.map(toXpathConstraint).join(` ${filter.name} `)+")":filter.name+"("+filter.parameters.map(toXpathConstraint).join(", ")+")"}}class DatabaseRetrieveExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="databaseRetrieve"}async execute(instruction,scope){const{entity:entity,constraints:constraints,limitExpr:limitExpr,offsetExpr:offsetExpr,takeFirst:takeFirst,sort:sort,outputVar:outputVar}=instruction,limit=limitExpr?this.evaluateExp(limitExpr,scope,"primitive"):void 0,offset=offsetExpr?this.evaluateExp(offsetExpr,scope,"primitive"):void 0,filter=constraints?function toQueryFilter(constraint,scope){switch(constraint.type){case"attribute":return constraint;case"function":return{type:"function",name:constraint.name,parameters:constraint.parameters.map(p=>toQueryFilter(p,scope))};case"literal":return{type:"value",value:toQueryFilterValue(constraint.value)};case"token":return{type:"value",value:expressionTokens[constraint.name]()};case"variable":return{type:"value",value:toQueryFilterValue(scope.get(constraint.name),constraint.attribute)}}}(constraints,scope):void 0,options=Object.assign(Object.assign(Object.assign({},offset?{offset:Number(offset)}:{}),limit?{amount:Number(limit)}:{}),sort?{sort:sort}:{}),{mxobjs:mxobjs}=mx.isOffline()?await mx.offlineData.retrieve(entity,filter,options):await mx.onlineData.retrieveByXPathNoSchema("//"+entity+(filter?`[${toXpathConstraint(filter)}]`:""),options);scope.set(outputVar,takeFirst?mxobjs[0]:mxobjs)}}class RollbackObjectsExecutor{constructor(){this.instructionType="rollbackObjects"}async execute(instruction,scope){const variable=scope.get(instruction.inputVar);if(variable instanceof MxObject)await rollback([variable]);else{if(!Array.isArray(variable))throw void 0===variable?new NanoflowError(`Cannot rollback $${instruction.inputVar} as it is empty`):new AssertionError;await rollback(variable)}}}async function rollback(mxobjs){return new Promise((resolve,reject)=>mx.data.rollback({mxobjs:mxobjs,callback:resolve,error:reject}))}class SynchronizeExecutor{constructor(){this.instructionType="synchronize"}async execute(_instruction,_scope){await methodToPromise(mx.data,"synchronizeOffline",{})}}class ReturnExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="return"}async execute(instruction,scope){return{result:this.evaluateExp(instruction.result,scope,instruction.resultKind)}}}class SetVariableExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="setVariable"}async execute(instruction,scope){scope.set(instruction.outputVar,this.evaluateExp(instruction.value,scope,instruction.outputKind))}}class SortListExecutor{constructor(){this.instructionType="sortList"}async execute(instruction,scope){const input=scope.get(instruction.inputVar);let arrCopy=Array.isArray(input)?input.slice():[];const meta=mx.meta.getEntity(instruction.entity);instruction.items.slice().reverse().forEach(item=>{const dataType=meta.getAttributeType(item.attribute),[validObjs,emptyObjs]=partition(arrItem=>{const attr=arrItem.get(item.attribute);return""!==attr&&void 0!==attr},arrCopy);switch(dataType){case"DateTime":validObjs.sort(applyOrdering(item.order,(a,b)=>a.get(item.attribute)-b.get(item.attribute)));break;case"AutoNumber":case"String":case"Enum":case"HashString":validObjs.sort(applyOrdering(item.order,(a,b)=>{const aAttr=a.get(item.attribute),bAttr=b.get(item.attribute);return(aAttr>bAttr?1:0)-(bAttr>aAttr?1:0)}));break;case"Long":case"Integer":case"Decimal":validObjs.sort(applyOrdering(item.order,(a,b)=>{const aAttr=a.get(item.attribute),bAttr=b.get(item.attribute);return aAttr.cmp(bAttr)}));break;case"Boolean":validObjs.sort(applyOrdering(item.order,(a,b)=>{const aAttr=a.get(item.attribute);return aAttr===b.get(item.attribute)?0:aAttr?1:-1}));break;default:throw new Error("Unsupported data type")}arrCopy=validObjs.concat(emptyObjs)}),scope.set(instruction.outputVar,arrCopy)}}function applyOrdering(ordering,compareFn){return(a,b)=>{const result=compareFn(a,b);return"desc"===ordering&&void 0!==result?-1*result:result}}class SwitchExecutor{constructor(exprEvaluator){this.exprEvaluator=exprEvaluator,this.instructionType="switch"}async execute(instruction,scope){const value=this.exprEvaluator(instruction.condition,scope,"primitive"),valueString=void 0!==value?value.toString():"";if(!(valueString in instruction.targets))throw new AssertionError;return{goto:instruction.targets[valueString]}}}class FlowScope{constructor(currentForm){this.currentForm=currentForm,this.map={},this.subscriptions=[],this.map.latestError=void 0}set(name,value){this.map[name]=value,value instanceof MxObject?this.subscriptions.push(subscribe({guid:value.getGuid()})):Array.isArray(value)&&this.subscriptions.push(...value.map(obj=>subscribe({guid:obj.getGuid()})))}get(name){if(!(name in this.map))throw new AssertionError;const value=this.map[name];return value instanceof MxObject&&value.isUnavailable()?void 0:Array.isArray(value)?value.filter(v=>!v.isUnavailable()):value}all(){return Object.keys(this.map)}mapGuidsToObjects(guids){const guidToObj={};return this.all().map(vn=>this.get(vn)).map(value=>value instanceof MxObject?[value]:Array.isArray(value)?value:[]).reduce((a,b)=>a.concat(b),[]).forEach(mxobj=>{guidToObj[mxobj.getGuid()]=mxobj}),guids.filter(guid=>guid in guidToObj).map(guid=>guidToObj[guid])}destroy(){this.subscriptions.forEach(s=>s.unsubscribe()),this.subscriptions.splice(0)}}class TryCatchExecutor{constructor(executeInstructions){this.executeInstructions=executeInstructions,this.instructionType="tryCatch"}async execute(instruction,scope){try{return void await this.executeInstructions(instruction.body,scope)}catch(e){return e instanceof Error?scope.set("latestError",e.message):null!=e?scope.set("latestError",e.toString()):scope.set("latestError",void 0),{goto:instruction.catchTarget}}}}class CloseFormExecutor{constructor(){this.instructionType="closeForm"}async execute(instruction,scope){scope.currentForm.closeMultiple(instruction.numberOfPages).catch(e=>mx.onError(e))}}class OpenFormExecutor{constructor(){this.instructionType="openForm"}async execute(instruction,scope){const param=instruction.inputVar?scope.get(instruction.inputVar):void 0;await mx.ui.openForm2(instruction.path,param?param.getGuid():void 0,instruction.title,scope.currentForm,instruction.params)}}class ShowMessageExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="showMessage"}async execute(instruction,scope){const expressionResult=this.evaluateExp(instruction.message,scope,"primitive"),message=void 0===expressionResult?"":expressionResult;mx.ui.showMessage(instruction.messageType,message,instruction.blocking)}}class ShowValidationExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="showValidation"}async execute(instruction,scope){const variable=scope.get(instruction.inputVar);if(void 0===variable)throw new NanoflowError(`Cannot refresh $${instruction.inputVar} as it is empty`);if(!(variable instanceof MxObject))throw new AssertionError;const expressionResult=this.evaluateExp(instruction.text,scope,"primitive"),validationText=void 0===expressionResult?"":expressionResult,existingValidations=function(scope,guid){const validationMap=scope[symbol]||(scope[symbol]={});return validationMap[guid]||(validationMap[guid]={})}(scope,variable.getGuid());existingValidations[instruction.member]=validationText;const ov=new ObjectValidation(variable.getGuid(),existingValidations);mx.data.sendValidationUpdates([ov])}}const symbol=Symbol("validations");class WriteLogExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="writeLog"}async execute(instruction,scope){const message=this.evaluateExp(instruction.message,scope,"primitive");mx.logger.log(instruction.level,message)}}function isReturn(value){return void 0!==value&&"object"==typeof value&&"result"in value}const nanoflowEngine=new class{constructor(lazyExecutors,getNanoflowFromRegistry){this.getNanoflowFromRegistry=getNanoflowFromRegistry,this.executors=lazyExecutors(this)}async execute(nanoflowId,args,currentForm){await wait(0);const scope=new FlowScope(currentForm);try{const instructions=this.getNanoflowFromRegistry(nanoflowId).instructions;return args.forEach(({name:name,value:value})=>scope.set(name,value)),await this.executeInstructions(instructions,scope)}finally{scope.destroy()}}async executeInstructions(instructions,scope){let index=0;for(;index<instructions.length;){const instruction=instructions[index],executor=this.executors.find(e=>e.instructionType===instruction.type);if(void 0===executor)throw new AssertionError;const executorResult=await executor.execute(instruction,scope);if(void 0!==(value=executorResult)&&"object"==typeof value&&"goto"in value){if(index=instructions.findIndex(i=>i.label===executorResult.goto),-1===index)throw new AssertionError}else{if(isReturn(executorResult))return executorResult.result;index++}}var value;throw new AssertionError}}(engine=>{const executeInstructions=(instructions,scope)=>engine.executeInstructions(instructions,scope),executeNanoflow=(nanoflowId,args,form)=>engine.execute(nanoflowId,args,form);return[new JumpExecutor,new SwitchExecutor(evaluateFlowExpression),new LoopExecutor(executeInstructions),new TryCatchExecutor(executeInstructions),new ReturnExecutor(evaluateFlowExpression),new CreateObjectExecutor,new ChangeObjectExecutor(evaluateFlowExpression),new CommitObjectsExecutor,new RollbackObjectsExecutor,new SetVariableExecutor(evaluateFlowExpression),new OpenFormExecutor,new CloseFormExecutor,new ShowValidationExecutor(evaluateFlowExpression),new DatabaseRetrieveExecutor(evaluateFlowExpression),new AssociationRetrieveExecutor,new WriteLogExecutor(evaluateFlowExpression),new JavaScriptActionExecutor(evaluateFlowExpression,executeNanoflow),new SynchronizeExecutor,new FilterListExecutor(evaluateFlowExpression),new SortListExecutor,new AggregateExecutor,new ShowMessageExecutor(evaluateFlowExpression),new NanoflowCallExecutor(evaluateFlowExpression,executeNanoflow),new MicroflowCallExecutor(evaluateFlowExpression)]},(function(nanoflowId){return nanoflowId()}));export{ObjectValidation as O,never as a,withFinally as b,methodToPromise as m,nanoflowEngine as n,wait as w};
