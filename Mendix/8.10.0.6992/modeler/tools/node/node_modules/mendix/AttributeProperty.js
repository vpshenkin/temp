import{o as observable,e as comparer,c as computed,I as valueMonitor,y as using,J as asReloadable,x as flatMapL,u as unavailable,f as available,b as action,F as reaction,w as mapL,h as getOrElseL,C as readUntracked}from"./2252f97c.js";import"react";import{e as ensure,m as mapValues,r as toFriendlyId}from"./e81b9882.js";import{e as asMobxProperty}from"./0ad2390d.js";import{d as evaluateFormExpression$,p as pageScope}from"./0b2c9cb2.js";import"./3cf8690e.js";import"./0e7164f2.js";import"big.js";import{t as translate}from"./11de92d0.js";import{q as attributeToClientValue,v as validate,s as validation,t as attributeValueToExpressionVariable,w as assertIsAttributeValue}from"./e4677d80.js";import"./c40e70cb.js";import{b as getActionParameters$,V as ValidationError}from"./dbc0cbf9.js";import"./d1a3b52a.js";import"./275ae0e7.js";import{A as Access,a as accessible}from"./449717b5.js";import{M as MxObject1,s as serverValidate$}from"./61ebc708.js";import{e as executeAction}from"./41e43d54.js";import{F as FormatterType}from"./09e8fbb9.js";import{c as createFormatter}from"./6e590920.js";function getValidationMessage(value,object,store,customValidator,config,widgetId){var _a,_b;const attributeType=object.getAttributeType(config.attribute);return"unparsed"===value.state?function(value,attribute,type){switch(type){case"Enum":case"Boolean":case"ObjectReference":case"ObjectReferenceSet":return translate("mendix.lib.Validations","invalid_attribute",value,attribute);case"DateTime":return translate("mendix.lib.Validations","invalid_date");case"Integer":case"Long":case"Decimal":return translate("mendix.lib.Validations","invalid_number");default:throw new Error(`Attribute type ${type} is not supported.`)}}(value.value,config.attribute,attributeType):null!==(_b=null!==(_a=function(value,type){const clientValue=attributeToClientValue(value),validationResult=validate(clientValue,type);if(validationResult===validation.OK)return;return translate("mendix.lib.Validations",validationCodeMap[validationResult])}(value.value,attributeType))&&void 0!==_a?_a:customValidator?customValidator(value.value):void 0)&&void 0!==_b?_b:config.validation?function(value,type,store,validationConfig,widgetId){if(!evaluateFormExpression$(validationConfig.expression,store,"Validation of "+widgetId,{value:()=>attributeValueToExpressionVariable(value,type,guid=>ensure(mx.data.getCachedObject(guid)))}))return validationConfig.message||translate("mendix.lib.Validations","required_field");return}(value.value,attributeType,store,config.validation,widgetId):void 0}const validationCodeMap={[validation.NOT_INTEGER]:"invalid_number",[validation.RANGE_INTEGER]:"range_integer",[validation.RANGE_LONG]:"range_long",[validation.RANGE_DECIMAL]:"range_decimal"};const AttributeProperty=asMobxProperty((config,store,widgetId)=>{var _a;const defaultFormatter=createFormatter(config.entity,config.attribute,null!==(_a=config.formatting)&&void 0!==_a?_a:{}),universe=function(config){const metaObject=mx.meta.getEntity(config.entity);switch(metaObject.getAttributeType(config.attribute)){case"Enum":return metaObject.getEnumMap(config.attribute).map(e=>e.key);case"Boolean":return[!0,!1];default:return}}(config),formatter=observable.box(defaultFormatter,{deep:!1}),invalidValue=observable.box(void 0,{deep:!1,equals:comparer.structural}),validation=observable.box(void 0);let customValidator;const submittedValue=computed(()=>{const path=config.path,rootObject=MxObject1.fromState$(store.get$(config.scope,"object")),object=path?flatMapL(rootObject,ro=>ro.getByPath$(path)):rootObject;return flatMapL(object,o=>{const attribute=o.get$(config.attribute);if(attribute.access===Access.None)return function(config,widgetId){mx.logger.debug(`No access to attribute "${config.attribute}" of entity "${config.entity}" in widget ${toFriendlyId(widgetId)}.`)}(config,widgetId),unavailable();const readOnlyState=Boolean(store.get$(pageScope,"subtreeReadonly"));try{const computedEditable=void 0===config.isEditable||evaluateFormExpression$(config.isEditable,store,"Editability of "+widgetId),readOnly=attribute.access===Access.Read||readOnlyState||!computedEditable;return available({object:o,attribute:attribute.value,readOnly:readOnly})}catch(e){return function(widgetId,e){mx.onError(new Error(`An error occurred while evaluating conditional editability expression in ${toFriendlyId(widgetId)}: ${e.message}`))}(widgetId,e),unavailable()}})}),submittedValueMonitor=valueMonitor(()=>submittedValue.get()),serverValidationMonitor=valueMonitor((function(){const object=mapL(submittedValue.get(),x=>x.object),validationL=mapL(object,o=>serverValidate$("Validation of "+widgetId,o.getGuid(),config.attribute));return getOrElseL(validationL,void 0)})),onChangeParameters$=getActionParameters$(config.onChange.argMap,store),result=using(()=>[reaction(()=>store.get$(pageScope,"validationRequest"),validateCurrentValue),reaction(()=>void 0!==validation.get(),isInvalid=>store.set(widgetId,"isInvalid",isInvalid),{fireImmediately:!0}),()=>store.set(widgetId,"isInvalid",!1),reaction(()=>getOrElseL(mapL(submittedValue.get(),v=>v.readOnly?void 0:v.object.old()),void 0),object=>store.set(widgetId,"object",void 0!==object?available(object):unavailable()),{fireImmediately:!0})],()=>{serverValidationMonitor.runIfChanged(val=>{validation.set(val?val[0]:void 0)}),submittedValueMonitor.runIfChanged(()=>{invalidValue.set(void 0),validation.set(void 0)});const submitted=submittedValue.get(),invalid=invalidValue.get(),value="available"!==submitted.status||void 0!==invalid&&"unparsed"===invalid.state?void 0:void 0!==invalid?invalid.value:submitted.value.attribute,displayValue="available"!==submitted.status?"":void 0!==invalid&&"unparsed"===invalid.state?invalid.value:formatter.get().format(void 0!==invalid?invalid.value:submitted.value.attribute);return{status:submitted.status,value:value,displayValue:displayValue,readOnly:"available"!==submitted.status||submitted.value.readOnly,validation:validation.get(),formatter:formatter.get(),universe:universe,setValidator:_customValidator=>{customValidator=_customValidator},setValue:action(newValue=>"available"!==submitted.status?noDataAvailableError(config,widgetId):submitted.value.readOnly?noWriteAccessError(config,widgetId):setValue({state:"parsed",value:newValue},submitted.value)),setTextValue:action(newValue=>"available"!==submitted.status?noDataAvailableError(config,widgetId):submitted.value.readOnly?noWriteAccessError(config,widgetId):setValue({state:"unparsed",value:newValue},submitted.value)),setFormatter:action(f=>formatter.set(null!=f?f:defaultFormatter))}}),reloadable=asReloadable(()=>result.get(),v=>({value:v.value,displayValue:v.displayValue}));return()=>reloadable.get();function validateCurrentValue(){var _a;const value=submittedValue.get();if("available"!==value.status)return;const currentValue=null!==(_a=invalidValue.get())&&void 0!==_a?_a:{state:"parsed",value:value.value.attribute};try{validation.set(getValidationMessage(currentValue,value.value.object,store,customValidator,config,widgetId))}catch(e){!function(widgetId,e){mx.onError(new Error(`An error occurred while validating current value in ${toFriendlyId(widgetId)}: ${e.message}`))}(widgetId,e)}}function setValue(newValue,newSubmittedValue){if("unparsed"===newValue.state){const currentValue=newSubmittedValue.attribute,formatterInstance=formatter.get(),parseResult=formatterInstance.type===FormatterType.DateTime&&currentValue instanceof Date?formatterInstance.parse(newValue.value,currentValue):formatterInstance.parse(newValue.value);newValue=parseResult.valid?{state:"parsed",value:parseResult.value}:newValue}else assertIsAttributeValue(newValue.value,config.entity,config.attribute);try{const object=newSubmittedValue.object,newValidation=getValidationMessage(newValue,object,store,customValidator,config,widgetId);if(void 0!==newValidation)validation.set(newValidation),invalidValue.set(newValue);else{const oldValue=object.get$(config.attribute);comparer.structural(oldValue,accessible(newValue.value))?(invalidValue.set(void 0),validation.set(void 0)):(object.set(config.attribute,newValue.value),function(){const parameters=readUntracked(onChangeParameters$),currentForm=ensure(store.get$(pageScope,"form"))[0];setTimeout(()=>{executeAction(config.onChange,{abortOnClientValidations:!0,abortOnServerValidations:!1,widgetIsValid:!0,currentForm:currentForm},mapValues(parameters,v=>getOrElseL(v,void 0)),void 0,e=>function(widgetId,e){e instanceof ValidationError||mx.onError(new Error(`An error occurred while executing On change at ${toFriendlyId(widgetId)}: ${e.message}`))}(widgetId,e))},0)}())}}catch(e){!function(widgetId,e){mx.onError(new Error(`An error occurred while validating new value set by ${toFriendlyId(widgetId)}: ${e.message}`))}(widgetId,e)}}});function noDataAvailableError(config,widgetId){mx.logger.debug(`Widget ${toFriendlyId(widgetId)} is attempting to change the value of attribute "${config.attribute}" of entity "${config.entity}" which is not available.`)}function noWriteAccessError(config,widgetId){mx.logger.debug(`Widget ${toFriendlyId(widgetId)} is attempting to change the value of attribute "${config.attribute}" of entity "${config.entity}" which is not writable.`)}export{AttributeProperty};
